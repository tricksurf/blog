<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>On the subject of TraceRays... - Tricksurf Blog</title><meta name="description" content="TraceRays are a tool in Counter-Strike: Source (and other Source Engine games) where you are able to send out a ray, like ray tracing, from any point and any direction you desire. This ray then gives back information that can be used to retrieve where&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://tricksurf.github.io/blog/on-the-subject-of-tracerays-2.html"><link rel="alternate" type="application/atom+xml" href="https://tricksurf.github.io/blog/feed.xml"><link rel="alternate" type="application/json" href="https://tricksurf.github.io/blog/feed.json"><meta property="og:title" content="On the subject of TraceRays..."><meta property="og:site_name" content="Tricksurf Blog"><meta property="og:description" content="TraceRays are a tool in Counter-Strike: Source (and other Source Engine games) where you are able to send out a ray, like ray tracing, from any point and any direction you desire. This ray then gives back information that can be used to retrieve where&hellip;"><meta property="og:url" content="https://tricksurf.github.io/blog/on-the-subject-of-tracerays-2.html"><meta property="og:type" content="article"><link rel="preload" href="https://tricksurf.github.io/blog/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://tricksurf.github.io/blog/assets/css/style.css?v=c41d75a0c1b84ac06a7da70d0722cf9d"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://tricksurf.github.io/blog/on-the-subject-of-tracerays-2.html"},"headline":"On the subject of TraceRays...","datePublished":"2023-01-23T22:32","dateModified":"2023-01-23T22:40","description":"TraceRays are a tool in Counter-Strike: Source (and other Source Engine games) where you are able to send out a ray, like ray tracing, from any point and any direction you desire. This ray then gives back information that can be used to retrieve where&hellip;","author":{"@type":"Person","name":"Nik McPhail","url":"https://tricksurf.github.io/blog/authors/nik-mcphail/"},"publisher":{"@type":"Organization","name":"Nik McPhail"}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://tricksurf.github.io/blog/">Tricksurf Blog</a></header><main><article class="post"><div class="hero"><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2023-01-23T22:32">January 23, 2023</time></div><h1>On the subject of TraceRays...</h1><div class="post__meta post__meta--author"><a href="https://tricksurf.github.io/blog/authors/nik-mcphail/" class="feed__author">Nik McPhail</a></div></div></header></div><div class="wrapper post__entry"><p>TraceRays are a tool in Counter-Strike: Source (and other Source Engine games) where you are able to send out a ray, like ray tracing, from any point and any direction you desire. This ray then gives back information that can be used to retrieve where it hits, if it hits an entity, and information from said entity. This blog aims to explain how we utilize TraceRay in ways the game doesnâ€™t intend.</p><h3 id="finding-the-function"><strong>Finding the Function</strong></h3><p>If we look through the leaked 2018 sdk, we can find TraceRay is a virtual function of the class IEngineTrace:</p><pre><code class="language-cpp">abstract_class IEngineTrace
{
public:
// 3 functions before...

        virtual void TraceRay( const Ray_t&amp; ray, unsigned int fMask, ITraceFilter *pTraceFilter, trace_t *pTrace ) = 0;
}
</code></pre><p>The great part about this function being part of IEngineTrace is that IEngineTrace is an interface. Interfaces are specific classes that allow us easy access to functions because the function that creates them is exported, meaning we can call it simply. As long as we have the CreateInterface function and a class with the same vtable offsets of functions we want to use, we can. We can define the CreateInterface function as such:</p><pre><code class="language-cpp">template &lt;typename T&gt;
inline T CreateInterface(const char* mod, const char* interfaceName)
{
        return (T)(((void* (*)(const char*, void*))GetProcAddress(GetModuleHandleA(mod), &quot;CreateInterface&quot;)(interfaceName, 0));
}
</code></pre></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on January 23, 2023</p><div class="post__share"></div><div class="post__bio bio"><div class="bio__info"><h3 class="bio__name"><a href="https://tricksurf.github.io/blog/authors/nik-mcphail/" rel="author">Nik McPhail</a></h3></div></div></footer></article></main><footer class="footer"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg><use xlink:href="https://tricksurf.github.io/blog/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script defer="defer" src="https://tricksurf.github.io/blog/assets/js/scripts.min.js?v=f47c11534595205f20935f0db2a62a85"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>